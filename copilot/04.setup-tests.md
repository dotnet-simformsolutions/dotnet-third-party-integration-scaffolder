# 04.setup-tests.md

🧪 **Task**  
Scaffold a complete, scalable, and maintainable test project in .NET for validating services, middleware, and third-party integrations. This is the final step of the project scaffolding process.

🎯 **Goal**  
Establish a cleanly structured unit test project that adheres to modern testing principles—featuring mocking, assertion fluency, separation of concerns, and alignment with the selected testing framework and architecture.

📥 **Inputs Required**

Prompt the user to select:
 - Testing Framework: xUnit, NUnit, or MSTest

🔧 **NuGet Package Installation (Dynamic)**

Automatically detect and install only the **required NuGet packages** based on selected inputs. Use the following logic:

- ✅ Detect `{TestFramework}` and install the corresponding base test package.
- ✅ Add a compatible **mocking library** (e.g., Moq).
- ✅ Add a **fluent assertions** package (e.g., FluentAssertions).
- ✅ If `{ProjectType}` is `WebAPI`, also install:
  - `Microsoft.AspNetCore.Mvc.Testing` for `WebApplicationFactory` support.

> ⚠️ Do **not** hardcode any package or version. All packages must be dynamically determined and installed using `dotnet add package` with compatibility validation against the target .NET version.

🏗️ **3. Test Project Setup**

### 🔍 Detect Existing Test Project (For Class Libraries Only)

If `{ProjectType}` = `Class Library`, check if the **host solution** already contains a unit test project:

- If yes, prompt the user:
  > "⚠️ A unit test project already exists at `{FullPathToExistingTestProject}`. Do you want to add the new tests into this existing project instead of creating a new one? (Yes/No)"
  
  - If `Yes` → Use the existing project. All new folders and test classes will be added inside it. Skip project creation.
  - If `No` → Prompt for a new test project name and create a new unit test project.

### 🆕 Project Creation (Only If New Project Needed)

If no existing test project is reused:

- Project Name (default): `{ServiceName}Service.Tests`
- Type: Unit Test Project
- Target: Same .NET version as the integration project
   
   Add project references and include the test project in the correct solution:

  - If integration type is class library 
        - Then add reference of integration project to this unit test project.
        - Then add this unit test project into host project's solution (`.sln`)
   - If integration type is MVC or Web API 
        - Then add appropriately reference to this unit test project
        - Then add this unit test project into relevant project's solution (`.sln`)
    
 📁 Folder Structure (create these explicitly):
     /Tests
        ├── /Services/{ServiceName}
        ├── /Controllers  # Only if controllers exist (IsStandalone == true)
        └── /Common

4. 🧪 Generate Unit Test Classes
  For each *Service.cs file in /Services/{ServiceName}:
  Create a corresponding *ServiceTests.cs in:
    - /Tests/Services/{ServiceName}/
  - Inspect constructor dependencies.
  - If the service implements an interface (e.g., IStripeService):
            - Mock the interface using `Mock<IService>()`.
  - If not, fallback to `Mock<Service>()` with a comment noting the lack of interface.
  - Declare mocks as `private readonly Mock<IDependency>`.
  - Initialize mocks in the test class constructor.
  - Instantiate the service with `.Object` properties of mocks.
  
  ✅ Method Convention
  For each public method:
        - Create a test stub following this convention:
            - `<MethodName>_Should<ExpectedOutcome>()`
        - Follow the AAA (Arrange → Act → Assert) pattern.
        - Use `.Setup(...).ReturnsAsync(...)` where applicable.
        - Use FluentAssertions for all assertions.
        - Maintain consistent naming and mocking patterns regardless of dependency count.

⚖️ Testing Principles
   ❌ Do not test private/internal methods directly
   ✅ Test only public methods that represent service boundaries
   ❌ Avoid real implementations unless mocking is impossible
   ✅ Always favor interface-driven design
   ✅ Maintain uniform structure, even if a service has zero dependencies

📘 Update /Docs/README.md
      - Add a `## Testing Setup` section including:
      - Selected test framework
      - List of installed NuGet packages
      - Folder structure of the test project
      - How to run tests via `dotnet test`
      - (Optional) How to collect code coverage using Coverlet or ReportGenerator

  Constraints:
   - Do not hardcode constructor logic or mocks. Always derive from the actual constructor signature.
   - Do not assume there are no dependencies.
   - Do not instantiate concrete services directly unless mocking via interface is not possible.
   - Do not assume the service has no dependencies. Even when there are none, maintain a consistent mocking template.
   - Keep tests interface-driven and fully decoupled from implementation.
   - Assume the main project compiles successfully and is already added to the solution.
   - Before creating any file, folder, project, or solution:
    - Check whether it already exists
    - If it exists:
        - Prompt user: "⚠️ {Item} already exists. Do you want to skip creation and reuse it? (Yes/No)"
        - Proceed based on response (skip or overwrite)
